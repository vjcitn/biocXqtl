---
title: "biocXqtl: flexible molecular QTL assessment"
shorttitle: "outlier dytection methods"
author: "Vincent J. Carey, stvjc at channing.harvard.edu"
date: "`r format(Sys.time(), '%B %d, %Y')`"
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{biocXqtl: flexible molecular QTL assessment}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document:
    highlight: pygments
    number_sections: yes
    theme: united
    toc: yes
---

# Introduction

eQTL analysis generally involves large data volumes
of genotype calls.  No standard representation
for genotypes has emerged, though VCFs and plink2
files are frequently encountered.

In this package we provide a flexible approach to
estimating associations between genotype and
molecular phenotypes such as gene expression
or DNA methylation.  We will use the
RangedSummarizedExperiment structure as the
primary element for structuring the inputs
to association test procedures.

# Preliminary illustration

## Basic data

`geuv19xse` is an extended RangedSummarizedExperiment derived
from the [GeuvadisTranscriptExpr](https://bioconductor.org/package/GeuvadisTranscriptExpr)
package.  The assay component provides transcript level counts.  Genotypes
are available through the getCalls method.

```{r do1, message=FALSE}
library(biocXqtl)
data(geuv19xse)
geuv19xse
assay(geuv19xse[1:3,1:4])
rowRanges(geuv19xse[1:3,])
getCalls(geuv19xse)[1:3,1:4]
```

## Filtering and testing with `bind_Zs`

From a computational viewpoint, the
simplest assessment of molecular QTLs involves fitting
a linear model to assess additive association of minor
allele dose with the molecular response.  From
an organizational viewpoint, a simple approach
is to start and end with an XqtlExperiment.
rowRanges will be updated to include Z-scores
for tests of association of each variant with each molecular feature.

```{r do2}
m = maf(geuv19xse)
mins = apply(data.matrix(cc <- mcols(getCalls(geuv19xse))), 1, min, na.rm=TRUE)
# also ensure that all possible genotype classes are seen 
ccc = data.matrix(cc)
tt = apply(ccc,1,function(x)length(table(x)))
ok = which(m > .3 & mins > -1 & tt == 3)   # very small sample size
limg = filterCalls(geuv19xse[1:100,], ok)
limg = bind_Zs(limg)
rowRanges(limg)[1:3,7:10]
```

All the Z-scores for tests of association are in the rowRanges
of `limg`.  The first 6 elements of the mcols of the rowRanges
are related to annotation.  A heatmap of the Z-scores
shows a band of transcripts with all zero counts.  Very light
tiles correspond to negative Z-scores, dark tiles to positive.

```{r lklll}
zs = data.matrix(mcols(rowRanges(limg))[,-c(1:6)])
zs[is.na(zs)] = 0
heatmap(zs, Colv=NA, scale="none")
```

## Focused visualization

With some helper functions, the basic data layout
can be seen, illustrating violation
of standard linear modeling assumptions underlying
interpretation of the Z-score.

```{r lkda}
mo = function(x) as.numeric(assay(limg[x,]))
sn = function(x) as.numeric(data.matrix(mcols(getCalls(limg)[x,])))
beeswarm::beeswarm(jitter(mo("ENST00000529442"))~sn("snp_19_19631444"))
```

## Visualization of associations over a region

An interactive comprehensive overview of filtered statistics
can be made.  For this illustration we start from scratch.

```{r demoplotly}
data(geuv19xse)
sds = rowSds(assay(geuv19xse), na.rm=TRUE)
qq = quantile(sds, .8)
ok = which(sds > qq)
lk = geuv19xse[ok,]
mafs = maf(lk) # only snps here
mins = apply(ccc <- data.matrix(mcols(getCalls(lk))), 1, min, na.rm=TRUE) # some -1 values
tt = apply(ccc,1,function(x)length(table(x)))
ok = which(m > .3 & mins > -1 & tt == 3)   # very small sample size
lk = filterCalls(lk, ok)
run1 <- bind_Zs(lk)
viz_stats(run1)
```

Zoom and axis restoration are available with standard plotly controls.

## Adding a covariatae

`bind_Zs` will use the covariate information present in colData().

For GEUVADIS data in GeuvadisTranscriptExpr, we have collected
sample-level information on sex.  Again we start from scratch,
filter, add the covariate information, and compute tests.

```{r addsex}
data(geuv19xse)
data(geuv19_samples)
sds = rowSds(assay(geuv19xse), na.rm=TRUE)
qq = quantile(sds, .8)
ok = which(sds > qq)
lk = geuv19xse[ok,]
mafs = maf(lk)
mins = apply(ccc <- data.matrix(mcols(getCalls(lk))), 1, min, na.rm=TRUE) # some -1 values
tt = apply(ccc,1,function(x)length(table(x)))
lk = filterCalls(lk,which(mafs>.3 & mins > -1 & tt == 3))
namedSex = geuv19_samples$Sex
names(namedSex) = geuv19_samples[["Sample name"]]
lk$Sex = namedSex[colnames(lk)]
table(lk$Sex)
run2 <- bind_Zs(lk)
```

The following display shows that there are SNP:transcript
associations for which adjustment for sample sex
can have appreciable effects on Z-score estimates
when absolute value of Z is less than 3 or so.

```{r lkests}
m2 = data.matrix(as.data.frame(mcols(run2)[,-c(1:6)]))
m1 = data.matrix(as.data.frame(mcols(run1)[,-c(1:6)]))
plot(as.numeric(m1) - as.numeric(m2)~as.numeric(m1), pch=".")
```

# Working with variants from VCF

Thanks to the AWS Open Data project, tabix-indexed VCFs for genotyped
lymphoblastoid cell lines from the 1000 genomes project
are [available](https://registry.opendata.aws/1000-genomes/).
Data from the Multi-Ancestry analysis of Gene Expression
are [available](https://github.com/mccoy-lab/MAGE)
via Zenodo or
Dropbox.  In our experience the Dropbox link is more performant.

We have acquired the "DESeq2" gene quantifications from
the MAGE archive, and a selection of `release` genotypes
from the associated cell lines.

## Data on expression and genotype

The expression data:
```{r theex}
data(mageSE_19)
```

Genotype data:
```{r lkgt}
dv = demo_vcf()
h = VariantAnnotation::scanVcfHeader(dv)
head(samples(h))
length(intersect(samples(h), colnames(mageSE_19)))
```

## Building an XqtlExperiment

We will focus on SNVs but the genotype information
has other types of variants.

Bind the minor allele counts to the expression data:
```{r dobind}
mins  = minorAlleleCounts(demo_vcf(), GRanges("19:1-50000000"))
mxx = XqtlExperiment(mageSE_19, mins)
colData(mxx) = NULL
```
The last command above allows us to compute crude measures of association.
If we populate colData with covariate information, test procedures
in the package will incorporate it.

## Creating association statistics with visualizations

The following step uses C++ modules to compute association tests for
all genotypes and all gene expression measures in mageSE_19.
```{r dotests}
sds = rowSds(assay(mxx), na.rm=TRUE)
qq = quantile(sds, .95)
ok = which(sds > qq)
system.time(zzz <- zs4manyYs(mxx[ok,]))
```

Here's a helper function to visualize one association.
```{r helper}
onebox = function(xse, mfeat="ENSG00000174837", vnt="rs4897932", title) {
if (missing(title)) title=""
boxplot(split(as.numeric(assay(xse[mfeat,])),
   as.numeric(data.matrix(mcols(getCalls(xse)[vnt,])))),
   ylab=mfeat, xlab=vnt, main=title)
}
onebox(mxx[ok,], title="MAGE eQTL")
```

We can also visualize interactively:
```{r doviz2}
tmpm = cbind(mcols(rowRanges(mxx[ok,])), zzz)
tmp = mxx[ok,]
mcols(tmp) = tmpm
viz_stats(tmp, midchop=5)
```

## Covariate adjustment

First we reanalyze with adjustment for continental group.

```{r redo}
data(mageSE_19)
sds = rowSds(assay(mageSE_19), na.rm=TRUE)
qq = quantile(sds, .9)
ok = which(sds > qq)
cd = colData(mageSE_19)
mins  = minorAlleleCounts(demo_vcf(), GRanges("19:1-3000000"))
mxx = XqtlExperiment(mageSE_19[ok,], mins)
print(mxx)
colData(mxx)=NULL
rowRanges(mxx) = rowRanges(mxx)[,1:6]
mxx$continent = cd$continentalGroup
system.time(zzz <- zs4manyYs(mxx))
mcols(rowRanges(mxx)) = cbind(mcols(rowRanges(mxx)), zzz)
viz_stats(mxx, midchop=5)
```

Then we add sex as well.

```{r redo2}
data(mageSE_19)
sds = rowSds(assay(mageSE_19), na.rm=TRUE)
qq = quantile(sds, .9)
ok = which(sds > qq)
cd = colData(mageSE_19)
mins  = minorAlleleCounts(demo_vcf(), GRanges("19:1-3000000"))
mxx = XqtlExperiment(mageSE_19[ok,], mins)
mxx$continent = cd$continentalGroup
mxx$sex = cd$sex
system.time(zzz <- zs4manyYs(mxx))
mcols(rowRanges(mxx)) = cbind(mcols(rowRanges(mxx)), zzz)
viz_stats(mxx, midchop=7)
```

