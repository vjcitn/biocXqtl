---
title: "biocXqtl: flexible molecular QTL assessment"
shorttitle: "outlier dytection methods"
author: "Vincent J. Carey, stvjc at channing.harvard.edu"
date: "`r format(Sys.time(), '%B %d, %Y')`"
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{biocXqtl: flexible molecular QTL assessment}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document:
    highlight: pygments
    number_sections: yes
    theme: united
    toc: yes
---

# Introduction

eQTL analysis generally involves large data volumes
of genotype calls.  No standard representation
for genotypes has emerged, though VCFs and plink2
files are frequently encountered.

In this package we provide a flexible approach to
estimating associations between genotype and
molecular phenotypes such as gene expression
or DNA methylation.  We will use the
RangedSummarizedExperiment structure as the
primary element for structuring the inputs
to association test procedures.

# Preliminary illustration

## Basic data

`geuv19` is a RangedSummarizedExperiment derived
from the [GeuvadisTranscriptExpr](https://bioconductor.org/package/GeuvadisTranscriptExpr)
package.  The assay component provides transcript level counts.  Genotypes
are available in the colData.

```{r do1, message=FALSE}
library(biocXqtl)
data(geuv19)
geuv19
assay(geuv19[1:3,1:4])
rowRanges(geuv19[1:3,])
colData(geuv19)[1:3,1:4]
```

## Filtering and testing with `bind_Zs`

From a computational viewpoint, the
simplest assessment of molecular QTLs involves fitting
a linear model to assess additive association of minor
allele dose with the molecular response.  From
an organizational viewpoint, a simple approach
is to start and end with a RangedSummarizedExperiment
instance.  `bind_Zs` carries this out for
the situation in which genotype calls are
managed in a natural way in colData.

```{r do2}
m = maf(colData(geuv19))
mins = apply(data.matrix(as.data.frame(colData(geuv19))), 2, min, na.rm=TRUE)
ok = which(m > .3 & mins > -1)   # very small sample size
limg = geuv19[1:100,]
colData(limg) = colData(limg)[,ok]
limg = bind_Zs(limg, 
   colselector=function(se) colnames(colData(se)))
limg
```

All the Z-scores for tests of association are in the rowRanges
of `limg`.  The first 6 elements of the mcols of the rowRanges
are related to annotation.  A heatmap of the Z-scores
shows a band of transcripts with all zero counts.  Very light
tiles correspond to negative Z-scores, dark tiles to positive.

```{r lklll}
zs = data.matrix(as.data.frame(mcols(rowRanges(limg))[,-c(1:6)]))
zs[is.na(zs)] = 0
heatmap(zs, Colv=NA, scale="none")
```

## Focused visualization

With some helper functions, the basic data layout
can be seen, illustrating violation
of standard linear modeling assumptions underlying
interpretation of the Z-score.

```{r lkda}
mo = function(x) as.numeric(assay(limg[x,]))
sn = function(x) as.numeric(colData(limg)[,x])
beeswarm::beeswarm(jitter(mo("ENST00000529442"))~sn("snp_19_19631444"))
```

## Visualization of associations over a region

An interactive comprehensive overview of filtered statistics
can be made.  For this illustration we start from scratch.

```{r demoplotly}
data(geuv19)
sds = rowSds(assay(geuv19), na.rm=TRUE)
qq = quantile(sds, .8)
ok = which(sds > qq)
lk = geuv19[ok,]
mafs = maf(colData(lk)) # only snps here
mins = apply(data.matrix(as.data.frame(colData(lk))), 2, min, na.rm=TRUE) # some -1 values
colData(lk) = colData(lk)[,which(mafs>.25 & mins > -1)]
run1 <- bind_Zs(lk, colselector = function(se) colnames(colData(se)))
viz_stats(run1)
```

Zoom and axis restoration are available with standard plotly controls.

## Adding a covariatae

`bind_Zs` will use the covariate information when a metadata
component `nonCallVars` is present and coincides with
a set of colData variables.  All colData variables not listed
in `nonCallVars` in metadata will be regarded as genotype calls.

For GEUVADIS data in GeuvadisTranscriptExpr, we have collected
sample-level information on sex.  Again we start from scratch,
filter, add the covariate information, and compute tests.

```{r addsex}
data(geuv19)
data(geuv19_samples)
sds = rowSds(assay(geuv19), na.rm=TRUE)
qq = quantile(sds, .8)
ok = which(sds > qq)
lk = geuv19[ok,]
mafs = maf(colData(lk)) # only snps here
mins = apply(data.matrix(as.data.frame(colData(lk))), 2, min, na.rm=TRUE) # some -1 values
colData(lk) = colData(lk)[,which(mafs>.25 & mins > -1)]
namedSex = geuv19_samples$Sex
names(namedSex) = geuv19_samples[["Sample name"]]
snpn = colnames(colData(lk))
lk$Sex = namedSex[colnames(lk)]
table(lk$Sex)
metadata(lk) = list(nonCallVars="Sex")
run2 <- bind_Zs(lk, colselector = function(se) snpn)  # filtered snp names
```

The following display shows that there are SNP:transcript
associations for which adjustment for sample sex
can have appreciable effects on Z-score estimates
when absolute value of Z is less than 3 or so.

```{r lkests}
m2 = data.matrix(as.data.frame(mcols(run2)[,-c(1:6)]))
m1 = data.matrix(as.data.frame(mcols(run1)[,-c(1:6)]))
plot(as.numeric(m1) - as.numeric(m2)~as.numeric(m1), pch=".")
```
