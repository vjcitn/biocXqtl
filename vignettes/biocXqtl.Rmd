---
title: "biocXqtl: flexible molecular QTL assessment"
shorttitle: "outlier dytection methods"
author: "Vincent J. Carey, stvjc at channing.harvard.edu"
date: "`r format(Sys.time(), '%B %d, %Y')`"
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{biocXqtl: flexible molecular QTL assessment}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document:
    highlight: pygments
    number_sections: yes
    theme: united
    toc: yes
---

# Introduction

eQTL analysis generally involves large data volumes
of genotype calls.  No standard representation
for genotypes has emerged, though VCFs and plink2
files are frequently encountered.

In this package we provide a flexible approach to
estimating associations between genotype and
molecular phenotypes such as gene expression
or DNA methylation.  We will use the
RangedSummarizedExperiment structure as the
primary element for structuring the inputs
to association test procedures.

# Preliminary illustration

`geuv19` is a RangedSummarizedExperiment derived
from the [GeuvadisTranscriptExpr](https://bioconductor.org/package/GeuvadisTranscriptExpr)
package.  The assay component provides transcript level counts.  Genotypes
are available in the colData.

```{r do1, message=FALSE}
library(biocXqtl)
data(geuv19)
geuv19
assay(geuv19[1:3,1:4])
rowRanges(geuv19[1:3,])
colData(geuv19)[1:3,1:4]
```

From a computational viewpoint, the
simplest assessment of molecular QTLs involves fitting
a linear model to assess additive association of minor
allele dose with the molecular response.  From
an organizational viewpoint, a simple approach
is to start and end with a RangedSummarizedExperiment
instance.  `bind_Zs` carries this out for
the situation in which genotype calls are
managed in a natural way in colData.

```{r do2}
m = maf(colData(geuv19))
mins = apply(data.matrix(as.data.frame(colData(geuv19))), 2, min, na.rm=TRUE)
ok = which(m > .3 & mins > -1)   # very small sample size
limg = geuv19[1:100,]
colData(limg) = colData(limg)[,ok]
limg = bind_Zs(limg, 
   colselector=function(se) colnames(colData(se)))
limg
```

All the Z-scores for tests of association are in the rowRanges
of `limg`.  The first 6 elements of the mcols of the rowRanges
are related to annotation.  A heatmap of the Z-scores
shows a band of transcripts with all zero counts.  Very light
tiles correspond to negative Z-scores, dark tiles to positive.

```{r lklll}
zs = data.matrix(as.data.frame(mcols(rowRanges(limg))[,-c(1:6)]))
zs[is.na(zs)] = 0
heatmap(zs, Colv=NA, scale="none")
```

With some helper functions, the basic data layout
can be seen, illustrating inappropriateness
standard linear modeling assumptions underlying
interpretation of the Z-score.

```{r lkda}
mo = function(x) as.numeric(assay(limg[x,]))
sn = function(x) as.numeric(colData(limg)[,x])
beeswarm::beeswarm(jitter(mo("ENST00000529442"))~sn("snp_19_19631444"))
```

An interactive comprehensive overview of filtered statistics
can be made.  For this illustration we start from scratch.

```{r demoplotly}
data(geuv19)
sds = rowSds(assay(geuv19), na.rm=TRUE)
qq = quantile(sds, .8)
ok = which(sds > qq)
lk = geuv19[ok,]
mafs = maf(colData(lk)) # only snps here
mins = apply(data.matrix(as.data.frame(colData(lk))), 2, min, na.rm=TRUE) # some -1 values
colData(lk) = colData(lk)[,which(mafs>.25 & mins > -1)]
lk <- bind_Zs(lk, colselector = function(se) colnames(colData(se)))
viz_stats(lk)
```

Zoom and axis restoration are available with standard plotly controls.
